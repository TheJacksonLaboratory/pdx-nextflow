#! /usr/bin/env python
"""
Read two VCF files, and compute allele frequencies.  Any alleles with
less than a specified frequency are dropped.  If no allele at a locus 
reached the specified threshold, the entire locus is dropped.

The first file is generated by the GATK variant caller.  Examples of its
output appear below.

The examples below assume that the specified frequency threshold is 5%.

Sample VCF input (from the CGA spec) (line breaks inserted for
readability):

#CHROM	POS	ID	REF	ALT	QUAL	FILTER	INFO	FORMAT	SAMPLE_143755
chr1    3638674 rs1801174       C       T       12152.20        .       
    AC=3;AF=0.750;AN=4;BaseQRankSum=4.142;DB;DP=368;Dels=0.00;FS=0.000;
    HaplotypeScore=8.8605;MLEAC=3;MLEAF=0.750;MQ=57.51;MQ0=0;
    MQRankSum=2.459;QD=33.02;ReadPosRankSum=-0.807      
    GT:AD:DP:GQ:MLPSAC:MLPSAF:PL    
    0/1/1/1:22,345:368:99:3:0.750:12179,1540,541,0,193
chr1    3643681 rs61736981      G       A       64.20   .       
    AC=1;AF=0.250;AN=4;BaseQRankSum=-1.530;DB;DP=291;Dels=0.00;FS=0.000;
    HaplotypeScore=2.8234;MLEAC=1;MLEAF=0.250;MQ=57.58;MQ0=0;
    MQRankSum=1.380;QD=0.22;ReadPosRankSum=-0.215      
    GT:AD:DP:GQ:MLPSAC:MLPSAF:PL    
    0/0/0/1:275,16:291:91:1:0.250:91,0,440,32767,32767
chr1    3649562 rs9662633       G       C,T       147.20  .       
    AC=1,1;AF=0.250,0.250;AN=4;BaseQRankSum=0.816;DB;DP=135;Dels=0.00;
    FS=0.000;HaplotypeScore=1.5518;MLEAC=1;MLEAF=0.250;MQ=57.83;MQ0=0;
    MQRankSum=0.269;QD=1.09;ReadPosRankSum=-0.720       
    GT:AD:DP:GQ:MLPSAC:MLPSAF:PL    
    0/0/1/2:100,29,6:135:99:1:0.250:174,0,183,32767,32767

Sample output from the above sample:

#CHROM	POS	REF	ALT	FILTER	REF_AF	ALT_AF
chr1	3638674 C	T	.	6%	94%
chr1	3643681	G	A	.	95%	5%
chr1	3649562	G	C	.	74%	21%

Note that the third allele of the third sample is not listed because
it rounded to less than 5%.  Note also that due to rounding the
totals may not come to 100%.

The second file is produced by the micro-indel caller pindel.  A sample
of its output is below (again, with line wrapping for readability):

chr3	195506078	.	G	GACCTGTGGATGCCGAGGAAGCGTCGGTGACAGGAAGAGGGGTGGTGTC
    .	PASS	END=195506078;HOMLEN=12;HOMSEQ=ACCTGTGGATGC;SVLEN=48;SVTYPE=INS
        GT:AD	0/0:509,22
chr3	195506102	.	C	CGGTGACAGGAAGAGGGGTGGTGTCACCTGTGGATACTGAGGAAAGGCT
    .	PASS	END=195506102;HOMLEN=15;HOMSEQ=GGTGACAGGAAGAGG;
    SVLEN=48;SVTYPE=INS GT:AD	0/0:473,3

Note that unlike the GATK variant caller, the pindel caller will only
call one non-reference allele per locus.

This script assumes that we're dealing with single sample VCFs, and
processes the first sample column.
"""

import sys


def usage():
    print >> sys.stderr, 'USAGE: {0} coverage_cutoff ' \
                         'low-threshold-SNV low-threshold-MicroIndel ' \
                         'SNV-input-VCF-file ' \
                         'MicroIndel-input-VCF-file output-file'.\
                         format(sys.argv[0])
    print >> sys.stderr, '    The low-threshold is entered as an ' \
                         'integer percent, e.g., 5'
    sys.exit(1)


def process_header(line):
    """
    We're going to skip all the meta format lines that start with ##,
    and look only for the column label.  Do a cursory validation of
    the VCF file.
    """
    if line[:2] == '##':
        return False
    if line[0] != '#':
        # This is a logic error!  Report it and bail out.
        print >> sys.stderr, 'ERROR: Did not find expected column ' \
                             'header line. Exiting...'
        sys.exit(2)

    # The VCF spec requires that if genotype information is included
    # that the FORMAT column be in col 8.
    parts = line.split('\t')
    if len(parts) != 10:
        # Not a valid VCF file with genotype info with exactly
        # one sample.
        print >> sys.stderr, "Incorrect VCF columns..."
        raise Exception(3, 'ERROR: Incorrect number of VCF '
                           'columns: {0}'.format(len(parts)))
    if parts[8] != 'FORMAT':
        raise Exception(4, 'ERROR: Column 8 is not FORMAT. '
                           'Found {0}. Exiting.'.format(parts[8]))

    # We've found and validated the header
    print >> sys.stderr, "Found Header"
    return True


def process_snp_line(line, ad_field, of, cutoff, coverage_cutoff,
                     keep_low_variants):
    parts = line.rstrip().split('\t')

    # Get the columns we need...
    chr = parts[0]
    pos = parts[1]
    ref = parts[3]
    alleles = parts[4].split(',')
    filter = parts[6]
    
    if not ad_field:
        format_parts = parts[8].split(':')
        for n, v in enumerate(format_parts):
            if v == 'AD':
                ad_field = n
                break
        if not ad_field:
            print >> sys.stderr, 'ERROR: Could not find AD field in ' \
                                 'the FORMAT. Exiting.'
            sys.exit(5)
    # Get the comma-sep list of allele depths
    allele_depth_string = parts[9].split(':')[ad_field]
    allele_depths = allele_depth_string.split(',')
    total_allele_depth = 0.0
    
    for n in range(len(allele_depths)):
        ad = float(allele_depths[n])
        allele_depths[n] = ad
        total_allele_depth += ad

    # Now convert the allele_depths into rounded percentages and output.
    #
    # NOTE:
    # Any reads for which the total allele depth is < 140 we will report
    # 'NA'.
    
    # The reference is in allele_depths[0].  In rare cases, the 
    # total_allele_depth may be zero, in which case we don't need
    # this value, so we can skip calculating it.
    ref_percent = None
    if total_allele_depth > 0.0:
        ref_percent = int(round((allele_depths[0] * 100) /
                                total_allele_depth))

    # Process the non-ref allele depths
    ads = allele_depths[1:]
    for n in range(len(ads)):
        if total_allele_depth >= coverage_cutoff:
            allele_percent = int(round((ads[n] * 100) / 
                total_allele_depth))
            if (allele_percent < cutoff) and not keep_low_variants:
                continue
            allele_percent_str = '{0}%'.format(allele_percent)
            ref_percent_str = '{0}%'.format(ref_percent)
        else:
            allele_percent_str = 'NA'
            ref_percent_str = 'NA'
        print >> of, '{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t{6}'.format(
                chr, pos, ref, alleles[n], filter, ref_percent_str, 
                allele_percent_str)


def process_indel_line(line, of, cutoff, coverage_cutoff,
                       keep_low_variants):
    """Process the variant calls produced by the pindel micro-indel
    caller.
    
    Unlike the GATK SNP caller, 
    1. This caller only calls one variant allele per locus.
    2. Does not include an AD field. We have to calculate it by adding
       all the allele read counts."""

    parts = line.rstrip().split('\t')
    # Get the columns we need...
    chr = parts[0]
    pos = parts[1]
    ref = parts[3]
    allele = parts[4]
    filter = parts[6]
    sample_data = parts[9]
    
    allele_counts = sample_data.split(':')[1]
    ref_cnt, allele_cnt = allele_counts.split(',')
    
    ref_cnt = float(ref_cnt)
    allele_cnt = float(allele_cnt)
    
    # Do we have enough read depth?
    depth = ref_cnt + allele_cnt
    if depth >= coverage_cutoff:
        allele_percent = int(round((allele_cnt * 100) / depth))
        # Leave if we don't make the allele percent cutoff, for
        # example, 5%.
        if (allele_percent < cutoff) and not keep_low_variants:
            return
        allele_percent_str = '{0}%'.format(allele_percent)
        ref_percent = int(round((ref_cnt * 100) / depth))
        ref_percent_str = '{0}%'.format(ref_percent)
    else:
        # Record that there was an identified allele here, but that
        # it had insufficient read depth to be reliable.
        allele_percent_str = 'N/A'
        ref_percent_str = 'N/A'
    print >> of, '{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t{6}'.format(
            chr, pos, ref, allele, filter, ref_percent_str, 
            allele_percent_str)
    
    
def main():
    # Check for a version request.
    if '--version' in sys.argv:
        print >> sys.stderr, 'allele_frequency_from_vcf 2015-11-18'
        sys.exit(0)

    # While Clinical CTP throws out variants that are below 5% AF,
    # PDX wants to keep them and simply flag them in the genomis DB
    # so they're available for researchers.
    keep_low_variants = False
    if '--keep' in sys.argv:
        keep_low_variants = True
        sys.argv.remove('--keep')

    # Program parameters
    COVERAGE_CUTOFF_IDX = 1
    SNP_CUTOFF_IDX = 2
    INDEL_CUTOFF_IDX = 3
    IN_SNPS_IDX = 4
    IN_INDEL_IDX = 5
    OUTF_IDX = 6

    # This program is invoked twice, once with snps and indels, and
    # once with only snps.  This section of code maps the arguments
    # into a common place.
    if len(sys.argv) != 5 and len(sys.argv) != 7:
        usage()
    if len(sys.argv) == 5:
        sys.argv = [sys.argv[0], sys.argv[1], sys.argv[2], None,
                    sys.argv[3], None, sys.argv[4]]
    try:
        coverage_cutoff = int(sys.argv[COVERAGE_CUTOFF_IDX])
        snp_cutoff = int(sys.argv[SNP_CUTOFF_IDX])
    except Exception, e:
        print >> sys.stderr, e
        print >> sys.stderr
        usage()

    # Open our output file and print out the header.
    of = open(sys.argv[OUTF_IDX], 'w')
    print >> of, '#CHROM\tPOS\tREF\tALT\tFILTER\tREF_AF\tALT_AF'

    # Now process the snp input file line by line.
    header_seen = False
    ad_field = None
    with open(sys.argv[IN_SNPS_IDX]) as f:
        line = f.readline()
        # Loop over all the lines...
        while line:
            if not header_seen:
                try:
                    header_seen = process_header(line)
                except Exception as e:
                    if e[0] == 3:
                        # Not enough columns.
                        # this may be an empty VCF (i.e., no data lines
                        # after the header.) If there is data after this
                        # line, this is a fatal error in the file.
                        line = f.readline()
                        if line:
                            print >> sys.stderr, e[1]
                            sys.exit(e[0])
                        else:
                            # An empty file.  Leave this loop.
                            break
                    else:
                        # Unexpected error... Leave.
                        print >> sys.stderr, e[1]
                        sys.exit(e[0])

            else:
                ad_field = process_snp_line(line, ad_field, of,
                                            snp_cutoff, coverage_cutoff,
                                            keep_low_variants)
            line = f.readline()

    # And now the Indel VCF if we were handed one.
    if sys.argv[IN_INDEL_IDX]:
        header_seen = False
        with open(sys.argv[IN_INDEL_IDX]) as f:
            line = f.readline()
            while line:
                if not header_seen:
                    try:
                        header_seen = process_header(line)
                    except Exception as e:
                        if e[0] == 3:
                            # Not enough columns.
                            # this may be an empty VCF (i.e., no data lines
                            # after the header.) If there is data after this
                            # line, this is a fatal error in the file.
                            line = f.readline()
                            if line:
                                print >> sys.stderr, e[1]
                                sys.exit(e[0])
                            else:
                                # An empty file.  Leave this loop.
                                break
                        else:
                            # Unexpected error... Leave.
                            print >> sys.stderr, e[1]
                            sys.exit(e[0])                        
                else:
                    try:
                        indel_cutoff = int(sys.argv[INDEL_CUTOFF_IDX])
                    except:
                        usage()
                    process_indel_line(line, of, indel_cutoff,
                                       coverage_cutoff,
                                       keep_low_variants)
                line = f.readline()
main()
